[
  {
    "id": "stage_localization",
    "term": "分段定位",
    "category": "排障与稳定性",
    "core": "分段定位把复杂链路拆成可验证阶段，快速缩小故障范围。",
    "boundary": "一上来全链路盲改，通常会引入新问题并延长恢复时间。",
    "signal": "报错信息不明确或链路较长时，分段定位是最高效策略。",
    "action": "按“入口->处理->存储->输出”逐段打日志，先确认哪一段首次异常。",
    "aliases": [
      "定位",
      "阶段"
    ]
  },
  {
    "id": "minimal_repro",
    "term": "最小复现",
    "category": "排障与稳定性",
    "core": "最小复现是把问题压缩到最小输入和最短路径，让修复从猜测变为实验。",
    "boundary": "拿生产全量数据调试会干扰变量，难以定位根因。",
    "signal": "同事无法复现你的 bug 时，优先产出最小复现脚本。",
    "action": "保留最小输入样本和单文件脚本，写清环境版本与复现步骤。",
    "aliases": [
      "复现",
      "minimal repro"
    ]
  },
  {
    "id": "selector_fallback",
    "term": "选择器备选",
    "category": "排障与稳定性",
    "core": "选择器备选策略用于页面结构变化时保持采集稳定，避免单点失效导致全量中断。",
    "boundary": "只依赖一个脆弱选择器，站点微调即全盘失败。",
    "signal": "网页采集场景中“偶发空数据”常是选择器不稳而非网络问题。",
    "action": "主选择器失败后按备选列表依次尝试，并记录命中率用于后续优化。",
    "aliases": [
      "selector"
    ]
  },
  {
    "id": "network_diagnosis",
    "term": "网络问题诊断",
    "category": "排障与稳定性",
    "core": "网络问题诊断要区分 DNS、连接、TLS、超时和应用层错误，不同层级处理方式完全不同。",
    "boundary": "把所有请求失败都归因于“目标网站挂了”会误导排障方向。",
    "signal": "接口大量超时或连接失败时，先做分层网络诊断再改业务逻辑。",
    "action": "依次检查 `ping/nslookup/curl -v`，记录失败层级并据此决定重试或降级。",
    "aliases": [
      "网络诊断"
    ]
  },
  {
    "id": "notify_diagnosis",
    "term": "推送故障诊断",
    "category": "排障与稳定性",
    "core": "推送故障诊断关注“消息是否产生、是否发送、是否到达、是否可见”四段链路。",
    "boundary": "只看发送接口返回成功，不代表接收端一定收到。",
    "signal": "告警未触达时，要把链路逐段核对，而不是直接重发。",
    "action": "给每条通知打唯一 trace_id；发送端、网关端、接收端三处日志都能按 id 检索。",
    "aliases": [
      "notify",
      "推送失败"
    ]
  },
  {
    "id": "dependency_pin",
    "term": "依赖版本锁定",
    "category": "排障与稳定性",
    "core": "依赖版本锁定用于防止上游变更导致行为漂移，是可复现构建和稳定运行的基础。",
    "boundary": "允许依赖随时间自动升级，故障出现时很难追责到具体版本。",
    "signal": "“昨天还好今天突然挂”且代码未变时，优先排查依赖版本变化。",
    "action": "锁定关键依赖版本并纳入 CI；升级走小步验证和回滚预案。",
    "aliases": [
      "版本锁定",
      "lock"
    ]
  },
  {
    "id": "safe_rerun",
    "term": "安全重跑",
    "category": "排障与稳定性",
    "core": "安全重跑要求任务具备幂等或补偿机制，避免二次执行造成重复写入。",
    "boundary": "失败后直接重跑而无防重策略，常造成脏数据和重复通知。",
    "signal": "批处理任务中断恢复、消息重复消费场景都需要安全重跑设计。",
    "action": "为任务定义幂等键和执行状态机；重跑前先跳过已成功记录。",
    "aliases": [
      "重跑",
      "rerun"
    ]
  },
  {
    "id": "sampling_validation",
    "term": "抽样校验",
    "category": "排障与稳定性",
    "core": "抽样校验通过小成本人工核查保证自动化结果质量，适合数据处理和模型输出验收。",
    "boundary": "完全不抽样会让系统性错误长期潜伏。",
    "signal": "流程新增规则或外部数据源变更后，应提高抽样比例。",
    "action": "按风险分层抽样（高风险高比例），记录错误类型并反哺规则改进。",
    "aliases": [
      "抽样",
      "校验"
    ]
  },
  {
    "id": "slo_thinking",
    "term": "SLO 思维",
    "category": "排障与稳定性",
    "core": "SLO 思维把“系统要多稳定”量化为目标（如可用性、延迟、错误率），避免稳定性讨论空泛。",
    "boundary": "没有目标就无法判断是否达标，也无法合理取舍开发速度与稳定性。",
    "signal": "服务进入长期运行阶段时，需要从“能跑”升级到“可承诺”。",
    "action": "先定义 1-2 个核心 SLO 和误差预算；每周复盘超标时段与改进动作。",
    "aliases": [
      "SLO",
      "稳定性指标"
    ]
  },
  {
    "id": "postmortem",
    "term": "故障复盘（Postmortem）",
    "category": "排障与稳定性",
    "core": "Postmortem 关注系统性改进，不追责个人，目标是防止同类事故再次发生。",
    "boundary": "复盘只写时间线不落改进项，价值会快速归零。",
    "signal": "出现中高优先级事故后，必须在记忆新鲜时完成复盘。",
    "action": "文档固定包含：影响范围、时间线、根因、处置、长期改进、负责人和截止日期。",
    "aliases": [
      "复盘",
      "postmortem"
    ]
  }
]
